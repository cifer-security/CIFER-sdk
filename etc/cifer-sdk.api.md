## API Report File for "cifer-sdk"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
interface AbiFunction {
    // (undocumented)
    inputs: Array<{
        name: string;
        type: string;
    }>;
    // (undocumented)
    name: string;
    // (undocumented)
    outputs?: Array<{
        name: string;
        type: string;
    }>;
    // (undocumented)
    stateMutability?: string;
    // (undocumented)
    type: 'function';
}

// @public
export type Address = `0x${string}`;

// @public
function assertCommitmentIntegrity(data: CommitmentData, metadata?: CIFERMetadata): void;

// @public
export class AuthError extends CiferError {
    constructor(message: string, cause?: Error);
}

declare namespace blackbox {
    export {
        payload,
        files,
        jobs,
        EncryptPayloadParams,
        EncryptPayloadResult,
        DecryptPayloadParams,
        DecryptPayloadResult,
        FileOperationParams,
        FileJobResult,
        DecryptExistingFileParams,
        DownloadParams,
        DeleteParams,
        ListJobsParams,
        ListJobsResult,
        DataConsumptionParams
    }
}

// @public
export class BlackboxError extends CiferError {
    constructor(message: string, options?: {
        statusCode?: number;
        endpoint?: string;
        cause?: Error;
    });
    readonly endpoint?: string;
    readonly statusCode?: number;
}

declare namespace blackboxNs {
    export {
        payload,
        files,
        jobs,
        EncryptPayloadParams,
        EncryptPayloadResult,
        DecryptPayloadParams,
        DecryptPayloadResult,
        FileOperationParams,
        FileJobResult,
        DecryptExistingFileParams,
        DownloadParams,
        DeleteParams,
        ListJobsParams,
        ListJobsResult,
        DataConsumptionParams
    }
}

// @public
export type BlockNumber = number;

// @public
export class BlockStaleError extends AuthError {
    constructor(blockNumber: number, currentBlock: number, maxWindow: number, cause?: Error);
    readonly blockNumber: number;
    readonly currentBlock: number;
    readonly maxWindow: number;
}

// @public
function buildCreateSecretTx(params: {
    chainId: ChainId;
    controllerAddress: Address;
    fee: bigint;
}): TxIntentWithMeta;

// @public
export function buildDataString(parts: string[]): string;

// @public
export function buildDecryptPayloadDataString(params: {
    chainId: ChainId;
    secretId: bigint | number;
    signer: string;
    blockNumber: number;
    encryptedMessage: string;
}): string;

// @public
export function buildEncryptPayloadDataString(params: {
    chainId: ChainId;
    secretId: bigint | number;
    signer: string;
    blockNumber: number;
    plaintext: string;
}): string;

// @public
export function buildFileOperationDataString(params: {
    chainId: ChainId;
    secretId: bigint | number;
    signer: string;
    blockNumber: number;
}): string;

// @public
export function buildJobDeleteDataString(params: {
    chainId: ChainId;
    secretId: bigint | number;
    signer: string;
    blockNumber: number;
    jobId: string;
}): string;

// @public
export function buildJobDownloadDataString(params: {
    chainId: ChainId;
    secretId: bigint | number;
    signer: string;
    blockNumber: number;
    jobId: string;
}): string;

// @public
export function buildJobsListDataString(params: {
    chainId: ChainId;
    secretId: bigint | number;
    signer: string;
    blockNumber: number;
}): string;

// @public
function buildRemoveDelegationTx(params: {
    chainId: ChainId;
    controllerAddress: Address;
    secretId: bigint;
}): TxIntentWithMeta;

// @public
function buildSetDelegateTx(params: {
    chainId: ChainId;
    controllerAddress: Address;
    secretId: bigint;
    newDelegate: Address;
}): TxIntentWithMeta;

// @public
interface BuildStoreCommitmentParams {
    args: {
        key: Bytes32;
        secretId: bigint;
        encryptedMessage: Hex;
        cifer: Hex;
    };
    chainId: ChainId;
    contractAddress: Address;
    storeFunction: AbiFunction;
    validate?: boolean;
}

// @public
function buildStoreCommitmentTx(params: BuildStoreCommitmentParams): TxIntentWithMeta;

// @public
function buildTransferSecretTx(params: {
    chainId: ChainId;
    controllerAddress: Address;
    secretId: bigint;
    newOwner: Address;
}): TxIntentWithMeta;

// @public
export type Bytes32 = `0x${string}`;

// @public
function bytesToHex(bytes: Uint8Array): Hex;

// @public
export interface CallRequest {
    blockTag?: 'latest' | 'pending' | number;
    data: Hex;
    to: Address;
}

// @public
export interface ChainConfig {
    blockTimeMs?: number;
    chainId: ChainId;
    name?: string;
    rpcUrl: string;
    secretsControllerAddress: Address;
    wsRpcUrl?: string;
}

// @public
export type ChainId = number;

// @public
export class ChainNotSupportedError extends ConfigError {
    constructor(chainId: number, cause?: Error);
    readonly chainId: number;
}

// @public
export const CIFER_ENCRYPTED_ABI: readonly [{
    readonly type: "function";
    readonly name: "CIFER_ENVELOPE_BYTES";
    readonly inputs: readonly [];
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "pure";
}, {
    readonly type: "function";
    readonly name: "MAX_PAYLOAD_BYTES";
    readonly inputs: readonly [];
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "pure";
}, {
    readonly type: "function";
    readonly name: "getCIFERMetadata";
    readonly inputs: readonly [{
        readonly name: "dataId";
        readonly type: "bytes32";
    }];
    readonly outputs: readonly [{
        readonly name: "secretId";
        readonly type: "uint256";
    }, {
        readonly name: "storedAtBlock";
        readonly type: "uint64";
    }, {
        readonly name: "ciferHash";
        readonly type: "bytes32";
    }, {
        readonly name: "encryptedMessageHash";
        readonly type: "bytes32";
    }];
    readonly stateMutability: "view";
}, {
    readonly type: "function";
    readonly name: "ciferDataExists";
    readonly inputs: readonly [{
        readonly name: "dataId";
        readonly type: "bytes32";
    }];
    readonly outputs: readonly [{
        readonly name: "exists";
        readonly type: "bool";
    }];
    readonly stateMutability: "view";
}, {
    readonly type: "event";
    readonly name: "CIFERDataStored";
    readonly inputs: readonly [{
        readonly name: "dataId";
        readonly type: "bytes32";
        readonly indexed: true;
    }, {
        readonly name: "secretId";
        readonly type: "uint256";
        readonly indexed: true;
    }, {
        readonly name: "cifer";
        readonly type: "bytes";
        readonly indexed: false;
    }, {
        readonly name: "encryptedMessage";
        readonly type: "bytes";
        readonly indexed: false;
    }, {
        readonly name: "ciferHash";
        readonly type: "bytes32";
        readonly indexed: false;
    }, {
        readonly name: "encryptedMessageHash";
        readonly type: "bytes32";
        readonly indexed: false;
    }];
}, {
    readonly type: "event";
    readonly name: "CIFERDataUpdated";
    readonly inputs: readonly [{
        readonly name: "dataId";
        readonly type: "bytes32";
        readonly indexed: true;
    }, {
        readonly name: "secretId";
        readonly type: "uint256";
        readonly indexed: true;
    }, {
        readonly name: "cifer";
        readonly type: "bytes";
        readonly indexed: false;
    }, {
        readonly name: "encryptedMessage";
        readonly type: "bytes";
        readonly indexed: false;
    }, {
        readonly name: "ciferHash";
        readonly type: "bytes32";
        readonly indexed: false;
    }, {
        readonly name: "encryptedMessageHash";
        readonly type: "bytes32";
        readonly indexed: false;
    }];
}, {
    readonly type: "event";
    readonly name: "CIFERDataDeleted";
    readonly inputs: readonly [{
        readonly name: "dataId";
        readonly type: "bytes32";
        readonly indexed: true;
    }];
}];

// @public
export const CIFER_ENVELOPE_BYTES = 1104;

// @public
function ciferDataExists(params: CommitmentReadParams, dataId: Bytes32): Promise<boolean>;

// @public
export class CiferError extends Error {
    constructor(message: string, code: string, cause?: Error);
    readonly cause?: Error;
    readonly code: string;
}

// @public
export interface CIFERMetadata {
    ciferHash: Bytes32;
    encryptedMessageHash: Bytes32;
    secretId: bigint;
    storedAtBlock: number;
}

// @public
export interface CiferSdk {
    // Warning: (ae-forgotten-export) The symbol "blackboxNs" needs to be exported by the entry point index.d.ts
    readonly blackbox: typeof blackboxNs;
    readonly blackboxUrl: string;
    // Warning: (ae-forgotten-export) The symbol "commitmentsNs" needs to be exported by the entry point index.d.ts
    readonly commitments: typeof commitmentsNs;
    readonly discovery: DiscoveryResult | null;
    // Warning: (ae-forgotten-export) The symbol "flowsNs" needs to be exported by the entry point index.d.ts
    readonly flows: typeof flowsNs;
    getControllerAddress(chainId: ChainId): Address;
    getRpcUrl(chainId: ChainId): string;
    getSupportedChainIds(): ChainId[];
    // Warning: (ae-forgotten-export) The symbol "keyManagementNs" needs to be exported by the entry point index.d.ts
    readonly keyManagement: typeof keyManagementNs;
    readonly readClient: ReadClient;
    refreshDiscovery(): Promise<void>;
    readonly signer?: SignerAdapter;
}

// @public
export interface CiferSdkConfig {
    blackboxUrl?: string;
    chainOverrides?: Record<ChainId, Partial<ChainConfig>>;
    discoveryCacheTtlMs?: number;
    fetch?: typeof fetch;
    logger?: (message: string) => void;
    readClient?: ReadClient;
    signer?: SignerAdapter;
}

// @public
export function clearDiscoveryCache(blackboxUrl?: string): void;

// @public
export interface CommitmentData {
    cifer: Hex;
    ciferHash: Bytes32;
    encryptedMessage: Hex;
    encryptedMessageHash: Bytes32;
}

// @public
export class CommitmentNotFoundError extends CommitmentsError {
    constructor(dataId: string, cause?: Error);
    readonly dataId: string;
}

// @public
interface CommitmentReadParams {
    chainId: ChainId;
    contractAddress: Address;
    readClient: ReadClient;
}

declare namespace commitments {
    export {
        getCIFERMetadata,
        ciferDataExists,
        CIFER_ENVELOPE_BYTES,
        MAX_PAYLOAD_BYTES,
        hexToBytes,
        bytesToHex,
        CommitmentReadParams,
        fetchCommitmentFromLogs,
        fetchCommitmentWithRetry,
        parseCommitmentLog,
        isCIFERDataEvent,
        FetchCommitmentParams,
        verifyCommitmentIntegrity,
        assertCommitmentIntegrity,
        validateForStorage,
        IntegrityResult,
        buildStoreCommitmentTx,
        COMMON_STORE_FUNCTIONS,
        BuildStoreCommitmentParams,
        AbiFunction
    }
}

// @public
export class CommitmentsError extends CiferError {
    constructor(message: string, cause?: Error);
}

declare namespace commitmentsNs {
    export {
        getCIFERMetadata,
        ciferDataExists,
        CIFER_ENVELOPE_BYTES,
        MAX_PAYLOAD_BYTES,
        hexToBytes,
        bytesToHex,
        CommitmentReadParams,
        fetchCommitmentFromLogs,
        fetchCommitmentWithRetry,
        parseCommitmentLog,
        isCIFERDataEvent,
        FetchCommitmentParams,
        verifyCommitmentIntegrity,
        assertCommitmentIntegrity,
        validateForStorage,
        IntegrityResult,
        buildStoreCommitmentTx,
        COMMON_STORE_FUNCTIONS,
        BuildStoreCommitmentParams,
        AbiFunction
    }
}

// @public
const COMMON_STORE_FUNCTIONS: {
    storeWithKey: {
        type: "function";
        name: string;
        inputs: {
            name: string;
            type: string;
        }[];
    };
    storeWithSecretId: {
        type: "function";
        name: string;
        inputs: {
            name: string;
            type: string;
        }[];
    };
};

// @public
export class ConfigError extends CiferError {
    constructor(message: string, cause?: Error);
}

// @public
export function createCiferSdk(config: CiferSdkConfig): Promise<CiferSdk>;

// @public
export function createCiferSdkSync(config: CiferSdkConfig & {
    readClient: ReadClient;
}): CiferSdk;

// @public
export function createReadClientFromDiscovery(chains: Array<{
    chainId: ChainId;
    rpcUrl: string;
}>): RpcReadClient;

// @public
function createSecretAndWaitReady(ctx: FlowContext, options?: FlowOptions): Promise<FlowResult<CreateSecretResult>>;

// @public
interface CreateSecretResult {
    secretId: bigint;
    state: SecretState;
}

// @public
export interface DataConsumption {
    decryption: {
        limit: number;
        used: number;
        remaining: number;
        count: number;
        limitGB: number;
        usedGB: number;
        remainingGB: number;
    };
    encryption: {
        limit: number;
        used: number;
        remaining: number;
        count: number;
        limitGB: number;
        usedGB: number;
        remainingGB: number;
    };
    wallet: Address;
}

// @public
function dataConsumption(params: DataConsumptionParams): Promise<DataConsumption>;

// @public
interface DataConsumptionParams {
    blackboxUrl: string;
    chainId: ChainId;
    fetch?: typeof fetch;
    readClient: ReadClient;
    signer: SignerAdapter;
}

// @public
function decryptExistingFile(params: DecryptExistingFileParams): Promise<FileJobResult>;

// @public
interface DecryptExistingFileFlowParams {
    encryptJobId: string;
    secretId: bigint;
}

// @public
function decryptExistingFileJobFlow(ctx: FlowContext, params: DecryptExistingFileFlowParams, options?: FlowOptions): Promise<FlowResult<DecryptFileFlowResult>>;

// @public
interface DecryptExistingFileParams {
    blackboxUrl: string;
    chainId: ChainId;
    encryptJobId: string;
    fetch?: typeof fetch;
    readClient: ReadClient;
    secretId: bigint | number;
    signer: SignerAdapter;
}

// @public
function decryptFile(params: FileOperationParams): Promise<FileJobResult>;

// @public
interface DecryptFileFlowParams {
    file: File | Blob;
    secretId: bigint;
}

// @public
interface DecryptFileFlowResult {
    decryptedFile: Blob;
    job: JobInfo;
    jobId: string;
}

// @public
function decryptFileJobFlow(ctx: FlowContext, params: DecryptFileFlowParams, options?: FlowOptions): Promise<FlowResult<DecryptFileFlowResult>>;

// @public
export class DecryptionError extends BlackboxError {
    constructor(message: string, cause?: Error);
}

// @public
function decryptPayload(params: DecryptPayloadParams): Promise<DecryptPayloadResult>;

// @public
interface DecryptPayloadParams {
    blackboxUrl: string;
    chainId: ChainId;
    cifer: string;
    encryptedMessage: string;
    fetch?: typeof fetch;
    inputFormat?: InputFormat;
    readClient: ReadClient;
    secretId: bigint | number;
    signer: SignerAdapter;
}

// @public
interface DecryptPayloadResult {
    decryptedMessage: string;
}

// @public
const DEFAULT_POLLING_STRATEGY: PollingStrategy;

// @public
function deleteJob(jobId: string, params: DeleteParams): Promise<void>;

// @public
interface DeleteParams {
    blackboxUrl: string;
    chainId: ChainId;
    fetch?: typeof fetch;
    readClient: ReadClient;
    secretId: bigint | number;
    signer: SignerAdapter;
}

// @public
export function discover(blackboxUrl: string, options?: {
    cacheTtlMs?: number;
    forceRefresh?: boolean;
    fetch?: typeof fetch;
}): Promise<DiscoveryResult>;

// @public
export class DiscoveryError extends ConfigError {
    constructor(message: string, blackboxUrl: string, cause?: Error);
    readonly blackboxUrl: string;
}

// @public
export interface DiscoveryResult {
    chains: ChainConfig[];
    enclaveWalletAddress: Address;
    fetchedAt: number;
    ipfsGatewayUrl?: string;
    status: 'ok' | string;
    supportedChains: ChainId[];
}

// @public
function download(jobId: string, params: DownloadParams): Promise<Blob>;

// @public
interface DownloadParams {
    blackboxUrl: string;
    chainId?: ChainId;
    fetch?: typeof fetch;
    readClient?: ReadClient;
    secretId?: bigint | number;
    signer?: SignerAdapter;
}

// @public
export interface Eip1193Provider {
    request(args: {
        method: string;
        params?: unknown[];
    }): Promise<unknown>;
}

// @public
export class Eip1193SignerAdapter implements SignerAdapter {
    constructor(provider: Eip1193Provider);
    clearCache(): void;
    getAddress(): Promise<Address>;
    sendTransaction(txRequest: TxIntent): Promise<TxExecutionResult>;
    signMessage(message: string): Promise<Hex>;
}

// @public
function encryptFile(params: FileOperationParams): Promise<FileJobResult>;

// @public
interface EncryptFileFlowParams {
    file: File | Blob;
    secretId: bigint;
}

// @public
interface EncryptFileFlowResult {
    encryptedFile: Blob;
    job: JobInfo;
    jobId: string;
}

// @public
function encryptFileJobFlow(ctx: FlowContext, params: EncryptFileFlowParams, options?: FlowOptions): Promise<FlowResult<EncryptFileFlowResult>>;

// @public
export class EncryptionError extends BlackboxError {
    constructor(message: string, cause?: Error);
}

// @public
function encryptPayload(params: EncryptPayloadParams): Promise<EncryptPayloadResult>;

// @public
interface EncryptPayloadParams {
    blackboxUrl: string;
    chainId: ChainId;
    fetch?: typeof fetch;
    outputFormat?: OutputFormat;
    plaintext: string;
    readClient: ReadClient;
    secretId: bigint | number;
    signer: SignerAdapter;
}

// @public
interface EncryptPayloadResult {
    chainId: ChainId;
    cifer: string;
    encryptedMessage: string;
    outputFormat: OutputFormat;
    secretId: bigint;
}

// @public
interface EncryptThenCommitParams {
    commitmentContract: `0x${string}`;
    key: Bytes32;
    plaintext: string;
    secretId: bigint;
    storeFunction?: AbiFunction;
}

// @public
interface EncryptThenCommitResult {
    cifer: Hex;
    encryptedMessage: Hex;
    txIntent: TxIntentWithMeta;
}

// @public
function encryptThenPrepareCommitTx(ctx: FlowContext, params: EncryptThenCommitParams, options?: FlowOptions): Promise<FlowResult<EncryptThenCommitResult>>;

// @public
function extractSecretIdFromReceipt(logs: Log[]): bigint;

// @public
function fetchCommitmentFromLogs(params: FetchCommitmentParams): Promise<CommitmentData>;

// @public
interface FetchCommitmentParams {
    chainId: ChainId;
    contractAddress: Address;
    dataId: Bytes32;
    readClient: ReadClient;
    storedAtBlock: number;
}

// @public
function fetchCommitmentWithRetry(params: FetchCommitmentParams & {
    blocksBefore?: number;
    blocksAfter?: number;
}): Promise<CommitmentData>;

// @public
interface FileJobResult {
    jobId: string;
    message: string;
}

// @public
interface FileOperationParams {
    blackboxUrl: string;
    chainId: ChainId;
    fetch?: typeof fetch;
    file: File | Blob;
    readClient: ReadClient;
    secretId: bigint | number;
    signer: SignerAdapter;
}

declare namespace files {
    export {
        encryptFile,
        decryptFile,
        decryptExistingFile,
        FileJobResult,
        FileOperationParams,
        DecryptExistingFileParams
    }
}

// @public
export class FlowAbortedError extends FlowError {
    constructor(flowName: string, stepName?: string, cause?: Error);
}

// @public
interface FlowContext {
    abortSignal?: AbortSignal;
    blackboxUrl: string;
    chainId: ChainId;
    controllerAddress?: Address;
    fetch?: typeof fetch;
    logger?: (message: string) => void;
    pollingStrategy?: PollingStrategy;
    readClient: ReadClient;
    signer: SignerAdapter;
    txExecutor?: TxExecutor;
}

// @public
export class FlowError extends CiferError {
    constructor(message: string, flowName: string, stepName?: string, cause?: Error);
    readonly flowName: string;
    readonly stepName?: string;
}

// @public
type FlowMode = 'plan' | 'execute';

// @public
interface FlowOptions {
    mode?: FlowMode;
    onStepProgress?: (step: FlowStep) => void;
}

// @public
interface FlowPlan {
    description: string;
    estimatedDurationMs?: number;
    name: string;
    steps: FlowStep[];
}

// @public
interface FlowResult<T> {
    data?: T;
    error?: Error;
    plan: FlowPlan;
    receipts?: TransactionReceipt[];
    success: boolean;
}

declare namespace flows {
    export {
        FlowMode,
        StepStatus,
        FlowStep,
        FlowPlan,
        PollingStrategy,
        FlowContext,
        FlowOptions,
        FlowResult,
        DEFAULT_POLLING_STRATEGY,
        createSecretAndWaitReady,
        CreateSecretResult,
        encryptThenPrepareCommitTx,
        EncryptThenCommitParams,
        EncryptThenCommitResult,
        retrieveFromLogsThenDecrypt,
        RetrieveAndDecryptParams,
        RetrieveAndDecryptResult,
        encryptFileJobFlow,
        decryptFileJobFlow,
        decryptExistingFileJobFlow,
        EncryptFileFlowParams,
        EncryptFileFlowResult,
        DecryptFileFlowParams,
        DecryptFileFlowResult,
        DecryptExistingFileFlowParams
    }
}

declare namespace flowsNs {
    export {
        FlowMode,
        StepStatus,
        FlowStep,
        FlowPlan,
        PollingStrategy,
        FlowContext,
        FlowOptions,
        FlowResult,
        DEFAULT_POLLING_STRATEGY,
        createSecretAndWaitReady,
        CreateSecretResult,
        encryptThenPrepareCommitTx,
        EncryptThenCommitParams,
        EncryptThenCommitResult,
        retrieveFromLogsThenDecrypt,
        RetrieveAndDecryptParams,
        RetrieveAndDecryptResult,
        encryptFileJobFlow,
        decryptFileJobFlow,
        decryptExistingFileJobFlow,
        EncryptFileFlowParams,
        EncryptFileFlowResult,
        DecryptFileFlowParams,
        DecryptFileFlowResult,
        DecryptExistingFileFlowParams
    }
}

// @public
interface FlowStep {
    description: string;
    error?: Error;
    id: string;
    result?: unknown;
    status: StepStatus;
    txIntent?: TxIntent;
    type: 'transaction' | 'api_call' | 'poll' | 'read' | 'compute';
}

// @public
export class FlowTimeoutError extends FlowError {
    constructor(flowName: string, timeoutMs: number, stepName?: string, cause?: Error);
    readonly timeoutMs: number;
}

// @public
function getCIFERMetadata(params: CommitmentReadParams, dataId: Bytes32): Promise<CIFERMetadata>;

// @public
function getDelegate(params: ReadParams, secretId: bigint): Promise<Address>;

// @public
export function getFreshBlockNumber(chainId: ChainId, readClient: ReadClient): Promise<number>;

// @public
export function getRpcUrl(chainId: ChainId, discovery: DiscoveryResult | null, overrides?: Record<ChainId, Partial<ChainConfig>>): string;

// @public
function getSecret(params: ReadParams, secretId: bigint): Promise<SecretState>;

// @public
function getSecretCreationFee(params: ReadParams): Promise<bigint>;

// @public
function getSecretOwner(params: ReadParams, secretId: bigint): Promise<Address>;

// @public
function getSecretsByWallet(params: ReadParams, wallet: Address): Promise<SecretsByWallet>;

// @public
export function getSecretsControllerAddress(chainId: ChainId, discovery: DiscoveryResult | null, overrides?: Record<ChainId, Partial<ChainConfig>>): string;

// @public
function getSecretsCountByWallet(params: ReadParams, wallet: Address): Promise<SecretsCountByWallet>;

// @public
function getStatus(jobId: string, blackboxUrl: string, options?: {
    fetch?: typeof fetch;
}): Promise<JobInfo>;

// @public
export function getSupportedChainIds(discovery: DiscoveryResult): ChainId[];

// @public
export type Hex = `0x${string}`;

// @public
function hexToBytes(hex: Hex): Uint8Array;

// @public
export type InputFormat = 'hex' | 'base64';

// @public
export class IntegrityError extends CommitmentsError {
    constructor(field: 'cifer' | 'encryptedMessage', expectedHash: string, actualHash: string, cause?: Error);
    readonly actualHash: string;
    readonly expectedHash: string;
    readonly field: 'cifer' | 'encryptedMessage';
}

// @public
interface IntegrityResult {
    checks: {
        ciferSize: {
            valid: boolean;
            actual: number;
            expected: number;
        };
        payloadSize: {
            valid: boolean;
            actual: number;
            max: number;
        };
        ciferHash?: {
            valid: boolean;
            expected?: string;
            actual?: string;
        };
        encryptedMessageHash?: {
            valid: boolean;
            expected?: string;
            actual?: string;
        };
    };
    valid: boolean;
}

// @public
export class InvalidCiferSizeError extends CommitmentsError {
    constructor(actualSize: number, expectedSize: number, cause?: Error);
    readonly actualSize: number;
    readonly expectedSize: number;
}

// @public
function isAuthorized(params: ReadParams, secretId: bigint, address: Address): Promise<boolean>;

// @public
export function isBlockStaleError(error: unknown): error is BlockStaleError;

// @public
export function isChainSupported(discovery: DiscoveryResult, chainId: ChainId): boolean;

// @public
function isCIFERDataEvent(log: Log): boolean;

// @public
export function isCiferError(error: unknown): error is CiferError;

// @public
export function isSecretNotReadyError(error: unknown): error is SecretNotReadyError;

// @public
function isSecretReady(params: ReadParams, secretId: bigint): Promise<boolean>;

// @public
export class JobError extends BlackboxError {
    constructor(message: string, jobId: string, cause?: Error);
    readonly jobId: string;
}

// @public
export interface JobInfo {
    chainId: ChainId;
    completedAt?: number;
    createdAt: number;
    error?: string;
    expiredAt?: number;
    id: string;
    originalSize?: number;
    progress: number;
    resultFileName?: string;
    secretId: number;
    status: JobStatus;
    ttl: number;
    type: JobType;
}

declare namespace jobs {
    export {
        getStatus,
        download,
        deleteJob,
        list,
        dataConsumption,
        pollUntilComplete,
        DownloadParams,
        DeleteParams,
        ListJobsParams,
        ListJobsResult,
        DataConsumptionParams
    }
}

// @public
export type JobStatus = 'pending' | 'processing' | 'completed' | 'failed' | 'expired';

// @public
export type JobType = 'encrypt' | 'decrypt';

declare namespace keyManagement {
    export {
        getSecretCreationFee,
        getSecret,
        getSecretOwner,
        getDelegate,
        getSecretsByWallet,
        getSecretsCountByWallet,
        isSecretReady,
        isAuthorized,
        ReadParams,
        SecretsByWallet,
        SecretsCountByWallet,
        buildCreateSecretTx,
        buildSetDelegateTx,
        buildRemoveDelegationTx,
        buildTransferSecretTx,
        parseSecretCreatedLog,
        parseSecretSyncedLog,
        parseDelegateUpdatedLog,
        extractSecretIdFromReceipt,
        ParsedSecretCreatedEvent,
        ParsedSecretSyncedEvent,
        ParsedDelegateUpdatedEvent
    }
}

// @public
export class KeyManagementError extends CiferError {
    constructor(message: string, cause?: Error);
}

declare namespace keyManagementNs {
    export {
        getSecretCreationFee,
        getSecret,
        getSecretOwner,
        getDelegate,
        getSecretsByWallet,
        getSecretsCountByWallet,
        isSecretReady,
        isAuthorized,
        ReadParams,
        SecretsByWallet,
        SecretsCountByWallet,
        buildCreateSecretTx,
        buildSetDelegateTx,
        buildRemoveDelegationTx,
        buildTransferSecretTx,
        parseSecretCreatedLog,
        parseSecretSyncedLog,
        parseDelegateUpdatedLog,
        extractSecretIdFromReceipt,
        ParsedSecretCreatedEvent,
        ParsedSecretSyncedEvent,
        ParsedDelegateUpdatedEvent
    }
}

// @public
function list(params: ListJobsParams): Promise<ListJobsResult>;

// @public
interface ListJobsParams {
    blackboxUrl: string;
    chainId: ChainId;
    fetch?: typeof fetch;
    includeExpired?: boolean;
    readClient: ReadClient;
    signer: SignerAdapter;
}

// @public
interface ListJobsResult {
    count: number;
    includeExpired: boolean;
    jobs: JobInfo[];
}

// @public
export interface Log {
    address: Address;
    blockNumber: number;
    data: Hex;
    logIndex: number;
    topics: Hex[];
    transactionHash: Hex;
    transactionIndex: number;
}

// @public
export interface LogFilter {
    address?: Address;
    fromBlock?: number | 'latest';
    toBlock?: number | 'latest';
    topics?: (Hex | null)[];
}

// @public (undocumented)
export const MAX_PAYLOAD_BYTES = 16384;

// @public
export class NotAuthorizedError extends KeyManagementError {
    constructor(secretId: bigint, caller: string, cause?: Error);
    readonly caller: string;
    readonly secretId: bigint;
}

// @public
export type OutputFormat = 'hex' | 'base64';

// Warning: (ae-internal-missing-underscore) The name "parseBlackboxErrorResponse" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export function parseBlackboxErrorResponse(response: {
    error?: string;
    message?: string;
}, statusCode: number, endpoint: string): BlackboxError;

// @public
function parseCommitmentLog(log: Log): CommitmentData;

// @public
interface ParsedDelegateUpdatedEvent {
    log: Log;
    newDelegate: Address;
    secretId: bigint;
}

// @public
function parseDelegateUpdatedLog(log: Log): ParsedDelegateUpdatedEvent;

// @public
interface ParsedSecretCreatedEvent {
    log: Log;
    owner: Address;
    secretId: bigint;
    secretType: number;
}

// @public
interface ParsedSecretSyncedEvent {
    clusterId: number;
    log: Log;
    publicKeyCid: string;
    secretId: bigint;
}

// @public
function parseSecretCreatedLog(log: Log): ParsedSecretCreatedEvent;

// @public
function parseSecretSyncedLog(log: Log): ParsedSecretSyncedEvent;

declare namespace payload {
    export {
        encryptPayload,
        decryptPayload,
        EncryptPayloadResult,
        DecryptPayloadResult,
        EncryptPayloadParams,
        DecryptPayloadParams
    }
}

// @public
export class PayloadTooLargeError extends CommitmentsError {
    constructor(actualSize: number, maxSize: number, cause?: Error);
    readonly actualSize: number;
    readonly maxSize: number;
}

// @public
interface PollingStrategy {
    backoffMultiplier?: number;
    intervalMs: number;
    maxAttempts: number;
    maxIntervalMs?: number;
}

// @public
function pollUntilComplete(jobId: string, blackboxUrl: string, options?: {
    intervalMs?: number;
    maxAttempts?: number;
    onProgress?: (job: JobInfo) => void;
    abortSignal?: AbortSignal;
    fetch?: typeof fetch;
}): Promise<JobInfo>;

// @public
export interface ReadClient {
    call?(chainId: ChainId, callRequest: CallRequest): Promise<Hex>;
    getBlockNumber(chainId: ChainId): Promise<number>;
    getLogs(chainId: ChainId, filter: LogFilter): Promise<Log[]>;
}

// @public
interface ReadParams {
    chainId: ChainId;
    controllerAddress: Address;
    readClient: ReadClient;
}

// @public
export function resolveAllChains(discovery: DiscoveryResult, overrides?: Record<ChainId, Partial<ChainConfig>>): Map<ChainId, ResolvedChainConfig>;

// @public
export function resolveChain(chainId: ChainId, discovery: DiscoveryResult | null, overrides?: Partial<ChainConfig>): ResolvedChainConfig;

// @public
export interface ResolvedChainConfig extends ChainConfig {
    fromDiscovery: boolean;
}

// @public
interface RetrieveAndDecryptParams {
    commitmentContract: Address;
    dataId: Bytes32;
    secretId: bigint;
    skipIntegrityCheck?: boolean;
    storedAtBlock?: number;
}

// @public
interface RetrieveAndDecryptResult {
    decryptedMessage: string;
    secretId: bigint;
    storedAtBlock: number;
}

// @public
function retrieveFromLogsThenDecrypt(ctx: FlowContext, params: RetrieveAndDecryptParams, options?: FlowOptions): Promise<FlowResult<RetrieveAndDecryptResult>>;

// @public
interface RetryOptions {
    maxRetries?: number;
    onRetry?: (attempt: number, error: BlockStaleError) => void;
    retryDelayMs?: number;
}

// @public
export class RpcReadClient implements ReadClient {
    constructor(config: RpcReadClientConfig);
    call(chainId: ChainId, callRequest: CallRequest): Promise<Hex>;
    getBlockNumber(chainId: ChainId): Promise<number>;
    getLogs(chainId: ChainId, filter: LogFilter): Promise<Log[]>;
    setRpcUrl(chainId: ChainId, rpcUrl: string): void;
}

// @public
export interface RpcReadClientConfig {
    fetch?: typeof fetch;
    rpcUrlByChainId: Record<ChainId, string>;
}

// Warning: (ae-internal-missing-underscore) The name "SdkContext" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export interface SdkContext {
    blackboxUrl: string;
    chainOverrides: Record<ChainId, Partial<ChainConfig>>;
    discovery: DiscoveryResult | null;
    fetch: typeof fetch;
    logger: (message: string) => void;
    readClient?: ReadClient;
    signer?: SignerAdapter;
}

// @public
export type SecretId = bigint;

// @public
export class SecretNotFoundError extends KeyManagementError {
    constructor(secretId: bigint, cause?: Error);
    readonly secretId: bigint;
}

// @public
export class SecretNotReadyError extends BlackboxError {
    constructor(secretId: bigint, cause?: Error);
    readonly secretId: bigint;
}

// @public
export const SECRETS_CONTROLLER_ABI: readonly [{
    readonly type: "function";
    readonly name: "secretCreationFee";
    readonly inputs: readonly [];
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
}, {
    readonly type: "function";
    readonly name: "defaultSecretType";
    readonly inputs: readonly [];
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "uint8";
    }];
    readonly stateMutability: "view";
}, {
    readonly type: "function";
    readonly name: "nextSecretId";
    readonly inputs: readonly [];
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
}, {
    readonly type: "function";
    readonly name: "getSecretState";
    readonly inputs: readonly [{
        readonly name: "secretId";
        readonly type: "uint256";
    }];
    readonly outputs: readonly [{
        readonly name: "owner";
        readonly type: "address";
    }, {
        readonly name: "delegate";
        readonly type: "address";
    }, {
        readonly name: "isSyncing";
        readonly type: "bool";
    }, {
        readonly name: "clusterId";
        readonly type: "uint8";
    }, {
        readonly name: "secretType";
        readonly type: "uint8";
    }, {
        readonly name: "publicKeyCid";
        readonly type: "string";
    }];
    readonly stateMutability: "view";
}, {
    readonly type: "function";
    readonly name: "getSecretOwner";
    readonly inputs: readonly [{
        readonly name: "secretId";
        readonly type: "uint256";
    }];
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "address";
    }];
    readonly stateMutability: "view";
}, {
    readonly type: "function";
    readonly name: "getDelegate";
    readonly inputs: readonly [{
        readonly name: "secretId";
        readonly type: "uint256";
    }];
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "address";
    }];
    readonly stateMutability: "view";
}, {
    readonly type: "function";
    readonly name: "getSecretsByWallet";
    readonly inputs: readonly [{
        readonly name: "wallet";
        readonly type: "address";
    }];
    readonly outputs: readonly [{
        readonly name: "owned";
        readonly type: "uint256[]";
    }, {
        readonly name: "delegated";
        readonly type: "uint256[]";
    }];
    readonly stateMutability: "view";
}, {
    readonly type: "function";
    readonly name: "getSecretsCountByWallet";
    readonly inputs: readonly [{
        readonly name: "wallet";
        readonly type: "address";
    }];
    readonly outputs: readonly [{
        readonly name: "ownedCount";
        readonly type: "uint256";
    }, {
        readonly name: "delegatedCount";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
}, {
    readonly type: "function";
    readonly name: "createSecret";
    readonly inputs: readonly [];
    readonly outputs: readonly [{
        readonly name: "secretId";
        readonly type: "uint256";
    }];
    readonly stateMutability: "payable";
}, {
    readonly type: "function";
    readonly name: "setDelegate";
    readonly inputs: readonly [{
        readonly name: "secretId";
        readonly type: "uint256";
    }, {
        readonly name: "newDelegate";
        readonly type: "address";
    }];
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
}, {
    readonly type: "function";
    readonly name: "transferSecret";
    readonly inputs: readonly [{
        readonly name: "secretId";
        readonly type: "uint256";
    }, {
        readonly name: "newOwner";
        readonly type: "address";
    }];
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
}, {
    readonly type: "event";
    readonly name: "SecretCreated";
    readonly inputs: readonly [{
        readonly name: "secretId";
        readonly type: "uint256";
        readonly indexed: true;
    }, {
        readonly name: "owner";
        readonly type: "address";
        readonly indexed: true;
    }, {
        readonly name: "secretType";
        readonly type: "uint8";
        readonly indexed: false;
    }];
}, {
    readonly type: "event";
    readonly name: "SecretSynced";
    readonly inputs: readonly [{
        readonly name: "secretId";
        readonly type: "uint256";
        readonly indexed: true;
    }, {
        readonly name: "clusterId";
        readonly type: "uint8";
        readonly indexed: true;
    }, {
        readonly name: "publicKeyCid";
        readonly type: "string";
        readonly indexed: false;
    }];
}, {
    readonly type: "event";
    readonly name: "DelegateUpdated";
    readonly inputs: readonly [{
        readonly name: "secretId";
        readonly type: "uint256";
        readonly indexed: true;
    }, {
        readonly name: "newDelegate";
        readonly type: "address";
        readonly indexed: true;
    }];
}, {
    readonly type: "event";
    readonly name: "SecretOwnershipTransferred";
    readonly inputs: readonly [{
        readonly name: "secretId";
        readonly type: "uint256";
        readonly indexed: true;
    }, {
        readonly name: "oldOwner";
        readonly type: "address";
        readonly indexed: true;
    }, {
        readonly name: "newOwner";
        readonly type: "address";
        readonly indexed: true;
    }];
}];

// @public
interface SecretsByWallet {
    delegated: bigint[];
    owned: bigint[];
}

// @public
interface SecretsCountByWallet {
    delegatedCount: bigint;
    ownedCount: bigint;
}

// @public
export interface SecretState {
    clusterId: number;
    delegate: Address;
    isSyncing: boolean;
    owner: Address;
    publicKeyCid: string;
    secretType: number;
}

// @public
export class SignatureError extends AuthError {
    constructor(message: string, cause?: Error);
}

// Warning: (ae-forgotten-export) The symbol "SignedData" needs to be exported by the entry point index.d.ts
//
// @public
export function signDataString(data: string, signer: SignerAdapter): Promise<SignedData>;

// @public
interface SignedData {
    data: string;
    signature: Hex;
    signer: string;
}

// @public
export interface SignerAdapter {
    getAddress(): Promise<Address>;
    sendTransaction?(txRequest: TxIntent): Promise<TxExecutionResult>;
    signMessage(message: string): Promise<Hex>;
}

// @public
export class SignerMismatchError extends AuthError {
    constructor(expected: string, actual: string, cause?: Error);
    readonly actual: string;
    readonly expected: string;
}

// @public
type StepStatus = 'pending' | 'in_progress' | 'completed' | 'failed' | 'skipped';

// @public
export interface TransactionReceipt {
    blockNumber: number;
    contractAddress?: Address;
    gasUsed: bigint;
    logs: Log[];
    status: 0 | 1;
    transactionHash: Hex;
}

// @public
export interface TxExecutionResult {
    hash: Hex;
    waitReceipt: () => Promise<TransactionReceipt>;
}

// @public
export type TxExecutor = (intent: TxIntent) => Promise<TxExecutionResult>;

// @public
export interface TxIntent {
    chainId: ChainId;
    data: Hex;
    to: Address;
    value?: bigint;
}

// @public
export interface TxIntentWithMeta extends TxIntent {
    args?: Record<string, unknown>;
    description: string;
    functionName: string;
}

// @public
function validateForStorage(cifer: Hex | Uint8Array, encryptedMessage: Hex | Uint8Array): void;

// @public
function verifyCommitmentIntegrity(data: CommitmentData, metadata?: CIFERMetadata): IntegrityResult;

// Warning: (ae-forgotten-export) The symbol "RetryOptions" needs to be exported by the entry point index.d.ts
//
// @public
export function withBlockFreshRetry<T>(fn: (getFreshBlock: () => Promise<number>) => Promise<T>, readClient: ReadClient, chainId: ChainId, options?: RetryOptions): Promise<T>;

```
