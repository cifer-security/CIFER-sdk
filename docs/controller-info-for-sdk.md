# CIFER SDK — on-chain “endpoints” (user-facing) reference for CiferSecretsControllerMultichain

This doc is written for an SDK agent: it describes **how to call CIFER smart-contract functions**, what they do, required params/value, and what to expect back (return values, events, common reverts).

## Scope / rules (important)

- **Endpoints = EVM contract calls** (JSON-RPC `eth_call` for reads, `eth_sendTransaction` for writes).
- **The SDK is initialized with the contract address** (or loads it from your own URL/config). Do not hardcode addresses.
- This doc covers the **user-facing surface**: reads + secret creation + (optional) delegation/transfer.
- **If you want a minimal SDK**: implement `createSecret()` and the read endpoints only.
- `createSecret(uint8 secretType)` exists on-chain; whether an SDK exposes it is a product decision. This doc treats **`createSecret()` (default type)** as the primary path.
- This doc covers **`CiferSecretsControllerMultichain` only**.

## Artifacts (ABIs)

Use these ABIs (already in repo):

- `Docs/CiferSecretsControllerMultichainABI.json`

## Contract: `CiferSecretsControllerMultichain`

User-facing functions live in `contracts/CiferSecretsControllerMultichain.sol`.

### Read endpoints (no gas, `eth_call`)

#### `secretCreationFee() -> uint256`

- **What it does**: Returns the exact native-token fee (wei) required when calling `createSecret()`.
- **How to call**: `eth_call` with no args.
- **Notes**:
  - This is a `public` state variable, so the getter is auto-generated by Solidity.
  - The SDK should read this right before sending `createSecret()` and pass it as the tx `value`.

#### `defaultSecretType() -> uint8`

- **What it does**: Returns the current default secret type used internally by `createSecret()`.
- **SDK behavior**: Read-only informational; the SDK **does not** allow choosing secret type.

#### `nextSecretId() -> uint256`

- **What it does**: Returns the next secret id that will be assigned.
- **SDK behavior**: Treat as informational only (race conditions exist if multiple users create secrets).
- **Gotcha**: On this contract, `nextSecretId` starts at **1** (the first created secretId will be `1`).

#### `getSecretState(uint256 secretId) -> (address owner, address delegate, bool isSyncing, uint8 clusterId, uint8 secretType, string publicKeyCid)`

- **What it does**: Returns the full on-chain state for a secret.
- **Common uses**:
  - Show owner/delegate
  - Detect readiness (`isSyncing == false`)
  - Read `publicKeyCid` once ready

**Reverts**
- `"Secret not found"` if `secretId` does not exist.

### Events (SDK-relevant)

#### `SecretCreated(uint256 indexed secretId, address indexed owner, uint8 secretType)`

- Emitted by `createSecret(...)` after state initialization.
- Useful for reliably extracting `secretId` from the transaction receipt.

#### `SecretSynced(uint256 indexed secretId, uint8 indexed clusterId, string publicKeyCid)`

- Emitted when a secret becomes ready: `isSyncing` transitions to `false` and `publicKeyCid` is set.
- **Who emits**: a **whitelisted blackbox** calling `markSecretSynced(...)` (not a normal user).
- **SDK relevance**: apps can watch this event (or poll `getSecretState`) to know when blackbox encryption/decryption becomes available.

#### `getSecretOwner(uint256 secretId) -> address`

- **What it does**: Convenience getter for owner.
- **Reverts**: `"Secret not found"` if missing.

#### `getDelegate(uint256 secretId) -> address`

- **What it does**: Convenience getter for delegate (can be `address(0)`).
- **Reverts**: `"Secret not found"` if missing.

#### `getSecretsByWallet(address wallet) -> (uint256[] owned, uint256[] delegated)`

- **What it does**: Returns all secret IDs owned by `wallet` and all secret IDs delegated to `wallet`.
- **Notes**:
  - Results are on-chain arrays; they can be large. Prefer `getSecretsCountByWallet` if you only need counts.
  - If `wallet` has no secrets, returns **empty arrays** (does not revert).
  - **Ordering is not stable**: the contract uses “swap-and-pop” when removing items from these arrays (e.g., when transferring a secret or changing a delegate), so the order of IDs can change over time.
  - Use these arrays as **sets**, not as ordered lists.

#### `getSecretsCountByWallet(address wallet) -> (uint256 ownedCount, uint256 delegatedCount)`

- **What it does**: Returns counts only (cheaper than returning full arrays).
 - **Return semantics**: returns `(0, 0)` if `wallet` has no secrets (does not revert).

### Write endpoints (transactions)

#### `createSecret() payable -> (uint256 secretId)`

- **What it does**: Creates a new secret owned by `msg.sender` and starts syncing.
- **Who can call**: Any user.
- **Tx value**: **MUST** be exactly `secretCreationFee()` (native token, in wei).
- **Returns**: `secretId` (as a Solidity return value; most SDKs should still parse it from the receipt/event).
- **Emits**:
  - `SecretCreated(uint256 indexed secretId, address indexed owner, uint8 secretType)`

**On-chain state changes**
- Increments `nextSecretId`
- Initializes secret fields:
  - `owner = msg.sender`
  - `delegate = address(0)`
  - `isSyncing = true`
  - `clusterId = 0`
  - `secretType = defaultSecretType`
  - `publicKeyCid = ""`

**Common reverts**
- `"Incorrect fee"` if `msg.value != secretCreationFee()`

**SDK call pattern**
- Read `fee = secretCreationFee()`
- Send tx `createSecret({ value: fee })`
- Wait for receipt, then:
  - Prefer extracting `secretId` from `SecretCreated` event (most robust)
  - Optionally also read `getSecretState(secretId)` to confirm creation

> Out of scope: `createSecret(uint8 secretType)` — do not expose in the SDK.

#### `setDelegate(uint256 secretId, address newDelegate)`

- **What it does**: Sets/updates the delegate for a secret. Setting `newDelegate = address(0)` clears delegation.
- **Who can call**: **Only the secret owner**.
- **Emits**:
  - `DelegateUpdated(uint256 indexed secretId, address indexed newDelegate)`

**Common reverts**
- `"Secret not found"` if missing
- `"Not secret owner"` if caller is not owner
- `"Delegate unchanged"` if setting to current delegate

#### `transferSecret(uint256 secretId, address newOwner)`

- **What it does**: Transfers secret ownership to `newOwner`. If a delegate is set, it will be cleared.
- **Who can call**: **Only the secret owner**.
- **Emits**:
  - `SecretOwnershipTransferred(uint256 indexed secretId, address indexed oldOwner, address indexed newOwner)`
  - `DelegateUpdated(secretId, address(0))` if a delegate existed and was cleared

**Common reverts**
- `"Secret not found"` if missing
- `"Not secret owner"` if caller is not owner
- `"New owner is zero"` if `newOwner == address(0)`
- `"Already secret owner"` if `newOwner` equals current owner

## Minimal SDK surface (suggested)

If you want a minimal “create + read” SDK, the minimal methods to generate are:

- `getSecretCreationFee()`
- `createSecret()` (default type only; tx `value = fee`)
- `getSecretState(secretId)`
- `getSecretOwner(secretId)`
- `getDelegate(secretId)`

Optional (common app needs, but not required for basic “create + use secret” flows):

- `setDelegate(secretId, newDelegate)` (owner-only)
- `transferSecret(secretId, newOwner)` (owner-only)

